# 你不知道的JavaScript（上卷）

![](http://md.raizo.club/你不知道的JavaScript上卷封面.png)
- **作者：Kyle Simpson** 
---

- [你不知道的JavaScript（上卷）](#你不知道的javascript上卷)
  - [- **作者：Kyle Simpson**](#--作者kyle-simpson)
  - [引擎、编译器、作用域](#引擎编译器作用域)
    - [1. 引擎](#1-引擎)
      - [LHS查询和RHS查询](#lhs查询和rhs查询)
    - [2. 编译器](#2-编译器)
    - [3. 作用域](#3-作用域)
      - [作用域嵌套](#作用域嵌套)
      - [词法作用域](#词法作用域)
      - [欺骗词法作用域](#欺骗词法作用域)
---

## 引擎、编译器、作用域

### 1. 引擎
>从头到尾负责整个 JavaScript 程序的编译及执行过程

引擎在执行编译器的代码时，需要查找作用域中的变量，那么引擎是如何查找的呢？
- __编译器在编译过程的第二步中生成了代码__，引擎执行它时，会通过查找变量来判断它是否已声明过。<u>查找的过程由作用域进行协助</u>，但是引擎执行怎样的查找，会影响最终的查找结果。

#### LHS查询和RHS查询


|   |LHS查询|RHS查询|
|---|---|---|
|查询方式|当 **变量** 出现在 **赋值操作** 的 `左侧` 时进行 `LHS查询` ，试图找到变量的容器，从而对其进行赋值|当 **变量** 出现在 **赋值操作** 的 `右侧` 时进行 `RHS查询` ，可以理解为就是简单地查找某个变量的值|
|非严格模式下查询失败|全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎|抛出  `ReferenceError` 异常|
|严格模式下查询失败|抛出 `ReferenceError` 异常|抛出 `TypeError` 异常|

`ReferenceError` 同作用域判别失败相关，而`TypeError` 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

**总结：**
- `LHS` 和 `RHS` 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。


### 2. 编译器
>负责语法分析及代码生成等


### 3. 作用域
>负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
**作用域是根据名称查找变量的一套规则**


#### 作用域嵌套
>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，<u>在当前作用域中无法找到某个变量时</u>，引擎就会 **在外层嵌套的作用域** 中 **继续查找**，。<mark>直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止</mark>。


#### 词法作用域
>由 **书写代码时函数声明的位置** 来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

|作用域分类||
|---|---|
|普通的|被大多数编程语言所采用的`词法作用域`|
|动态作用域|仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）|


#### 欺骗词法作用域
**作用**：在运行时修改词法作用域
**缺点**：**<mark>欺骗词法作用域会导致性能下降</mark>**
**方式**：`eval`, `setTimeout`, `setIntval`, `with`

- eval

```javascript
function test(str, a){
  eval(str);
  console.log(a, b);
}

var b = 2;
test("var b = 3;", 1);
```
运行结果： 1， 3 （在严格模式下，`eval` 无法修改作用域）

- with
```javascript
function test(obj){
  with(obj){
    a = 2;
  }
}

var o1 = {
  a: 1
}

var o2 = {
  b: 2
}

test(o1);
console.log(o1.a);

test(o2);
console.log(o2.a);
console.log(a);
```
运行结果：2， undefined  , 2
with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。

|eval与with的区别||
|---|---|
|eval|如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域|
|with|根据你传递给它的对象凭空创建了一个全新的词法作用域|

---

